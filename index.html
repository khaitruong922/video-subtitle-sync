<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Video Subtitle Sync</title>
  </head>
  <body>
    <div id="container">
      <div id="inputs">
        <div>
          <label for="video-input">Video File</label>
          <input type="file" id="video-input" accept="video/*" />
        </div>
        <div>
          <label for="subtitle-file-input">Subtitle File</label>
          <input type="file" id="subtitle-file-input" accept=".srt,.ass" />
        </div>
        <div>
          <label for="subtitle-offset">Subtitle offset (ms)</label>
          <input type="number" id="subtitle-offset" value="0" />
        </div>
      </div>
      <video id="video-player" controls></video>
      <div id="subtitle-container"></div>
      <div id="toggle-mode-btn"></div>
    </div>

    <script>
      let subtitles = [];
      let videoPlayer = document.getElementById("video-player");
      let subtitlesContainer = document.getElementById("subtitle-container");
      let offset = 0;

      function parseSRT(data) {
        const subtitles = [];
        const lines = data.split("\n").map((line) => line.trim());
        let currentIndex = -1;
        lines.forEach((line) => {
          if (/^\d+$/.test(line)) {
            currentIndex++;
          } else if (/^\d+:\d+:\d+,\d+ --> \d+:\d+:\d+,\d+$/.test(line)) {
            let [startTime, endTime] = line
              .split(" --> ")
              .map((time) => time.replace(",", "."));
            startTime = timeToSeconds(startTime);
            endTime = timeToSeconds(endTime);
            subtitles[currentIndex] = { startTime, endTime, text: "" };
          } else if (line === "") {
            currentIndex++;
          } else {
            subtitles[currentIndex].text += "\n" + line;
          }
        });
        return subtitles;
      }

      function parseASS(data) {
        const lines = data
          .split("\n")
          .map((line) => line.trim())
          .filter((line) => line.startsWith("Dialogue:"));
        return lines.map((line) => {
          const data = line.split(",");
          const text = data[9].split("\\N").join("\n");
          return {
            startTime: timeToSeconds(data[1], "."),
            endTime: timeToSeconds(data[2], "."),
            text,
          };
        });
      }

      const handleVideoInputChange = () => {
        const fileInput = document.getElementById("video-input");
        const file = fileInput.files[0];

        if (file) {
          const reader = new FileReader();

          reader.onload = function (e) {
            videoPlayer.src = URL.createObjectURL(file);
            document.title = file.name;
          };

          reader.readAsDataURL(file);
        }
      };

      const handleSubtitleFileChange = () => {
        const subtitleFileInput = document.getElementById(
          "subtitle-file-input"
        );
        const file = subtitleFileInput.files[0];
        if (file) {
          const ext = file.name.split(".").pop();
          const reader = new FileReader();
          reader.onload = function (e) {
            const content = e.target.result;
            switch (ext) {
              case "srt":
                subtitles = parseSRT(content);
                break;
              case "ass":
                subtitles = parseASS(content);
                break;
              default:
                alert("Invalid subtitle file");
                return;
            }
          };
          reader.readAsText(file);
        }
      };

      const timeToSeconds = (timeString, decimalSep = ",") => {
        const [hours, minutes, secondsWithMillis] = timeString.split(":");
        const [seconds, millis] = secondsWithMillis.split(decimalSep);
        const totalSeconds =
          parseInt(hours, 10) * 3600 +
          parseInt(minutes, 10) * 60 +
          parseInt(seconds, 10) +
          parseInt(millis || 0, 10) / 1000;
        return totalSeconds;
      };

      let prev = [];

      const displaySubtitles = () => {
        const currentTime = videoPlayer.currentTime + offset;
        const currentSubs = subtitles.filter(
          (subtitle) =>
            currentTime >= subtitle.startTime && currentTime <= subtitle.endTime
        );
        let changed = prev.length !== currentSubs.length;
        if (!changed) {
          for (let i = 0; i < prev.length; i++) {
            if (prev[i].text !== currentSubs[i].text) {
              changed = true;
              break;
            }
          }
        }
        if (changed) {
          prev = currentSubs;
          subtitlesContainer.innerHTML = "";
          currentSubs.forEach((subtitle) => {
            const lines = subtitle.text.split("\n");
            lines.forEach((line) => {
              const subtitleElement = document.createElement("div");
              subtitleElement.innerText = line;
              subtitlesContainer.appendChild(subtitleElement);
            });
          });
        }
      };

      const handleSubtitleoffsetChange = () => {
        const subtitleoffsetInput = document.getElementById("subtitle-offset");
        offset = parseInt(subtitleoffsetInput.value, 10) / 1000;
        displaySubtitles();
      };

      // Allow rewind and fast forward using the left and right arrow keys
      const rewindTime = 5;
      document.addEventListener("keydown", function (event) {
        if (document.activeElement !== document.body) {
          return;
        }

        if (event.key === "ArrowLeft" || event.key === "Left") {
          // Rewind by the specified time
          videoPlayer.currentTime = Math.max(
            0,
            videoPlayer.currentTime - rewindTime
          );
        }
        if (event.key === "ArrowRight" || event.key === "Right") {
          // Fast forward by the specified time
          videoPlayer.currentTime = Math.min(
            videoPlayer.duration,
            videoPlayer.currentTime + rewindTime
          );
        }

        if (event.key === " ") {
          // Toggle between play and pause
          if (videoPlayer.paused) {
            videoPlayer.play();
          } else {
            videoPlayer.pause();
          }
        }
      });

      const darkModeKey = "darkMode";
      let darkMode =
        localStorage.getItem(darkModeKey) === "false" ? false : true;
      const toggleModeBtn = document.getElementById("toggle-mode-btn");
      const toggleDarkMode = () => {
        darkMode = !darkMode;
        updateTheme();
      };
      const updateTheme = () => {
        if (darkMode) {
          document.body.classList.add("dark");
        } else {
          document.body.classList.remove("dark");
        }
        toggleModeBtn.innerText = darkMode ? "Light" : "Dark";
        localStorage.setItem(darkModeKey, darkMode);
      };
      updateTheme();

      document
        .getElementById("video-input")
        .addEventListener("change", handleVideoInputChange);
      document
        .getElementById("subtitle-file-input")
        .addEventListener("change", handleSubtitleFileChange);
      document
        .getElementById("subtitle-offset")
        .addEventListener("change", handleSubtitleoffsetChange);
      videoPlayer.addEventListener("timeupdate", displaySubtitles);
      toggleModeBtn.addEventListener("click", toggleDarkMode);
    </script>
  </body>
  <style>
    * {
      font-family: "Helvetica", "Arial", sans-serif;
      margin: 0;
      padding: 0;
    }
    html {
      overflow-y: scroll;
    }
    body {
      padding-top: 12px;
    }
    .dark {
      background-color: #000;
      color: #fff;
    }
    #subtitle-container {
      margin-top: 12px;
      font-size: 32px;
      text-align: center;
    }
    #container {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    #video-player {
      margin-top: 12px;
      height: 80vh;
    }
    #toggle-mode-btn {
      position: fixed;
      bottom: 16px;
      right: 16px;
      padding: 10px 25px;
      font-weight: bold;
      border: none;
      cursor: pointer;
      color: #fff;
      background-color: #000;
      border-radius: 25px;
    }
    .dark #toggle-mode-btn {
      color: #000;
      background-color: #fff;
    }
    input::-webkit-outer-spin-button,
    input::-webkit-inner-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }
    input[type="number"] {
      -moz-appearance: textfield;
    }
    input[type="file"] {
      padding: 0;
    }
    .hide {
      display: none;
    }
    #inputs {
      display: flex;
      flex-direction: row;
      align-items: center;
    }
  </style>
</html>
